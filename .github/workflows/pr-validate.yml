name: PR Validation

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'policies/**'

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate policy structure
        id: validate
        run: |
          echo "üîç Validating policy structure..."

          # Check for policies folder
          if [ ! -d "policies" ]; then
            echo "‚ùå Error: policies/ directory not found"
            exit 1
          fi

          validation_errors=0

          # Find all policy versions
          while IFS= read -r -d '' policy_dir; do
            policy_name=$(basename "$policy_dir")

            # Find version directories
            while IFS= read -r -d '' version_dir; do
              version=$(basename "$version_dir")

              echo "üìã Checking $policy_name/$version"

              # Check semantic versioning (vX.Y.Z)
              if ! [[ $version =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                echo "‚ùå Invalid version format '$version' in $policy_dir"
                ((validation_errors++))
                continue
              fi

              # Check required files
              required_files=("metadata.json" "policy-definition.yaml")
              required_dirs=("src" "docs")
              optional_dirs=("assets")

              for file in "${required_files[@]}"; do
                if [ ! -f "$version_dir/$file" ]; then
                  echo "‚ùå Missing required file: $file in $version_dir"
                  ((validation_errors++))
                fi
              done

              for dir in "${required_dirs[@]}"; do
                if [ ! -d "$version_dir/$dir" ]; then
                  echo "‚ùå Missing required directory: $dir/ in $version_dir"
                  ((validation_errors++))
                fi
              done

              # Check for optional assets directory (warning only)
              for dir in "${optional_dirs[@]}"; do
                if [ ! -d "$version_dir/$dir" ]; then
                  echo "‚ö†Ô∏è  Optional directory not found: $dir/ in $version_dir"
                fi
              done

              # Validate docs directory contents
              if [ -d "$version_dir/docs" ]; then
                docs_required_files=("overview.md" "configuration.md" "examples.md")
                docs_optional_files=("faq.md")
                
                for doc_file in "${docs_required_files[@]}"; do
                  if [ ! -f "$version_dir/docs/$doc_file" ]; then
                    echo "‚ùå Missing required docs file: docs/$doc_file in $version_dir"
                    ((validation_errors++))
                  fi
                done
                
                # Check for changelog (can be README.md or CHANGELOG.md)
                if [ ! -f "$version_dir/docs/README.md" ] && [ ! -f "$version_dir/docs/CHANGELOG.md" ]; then
                  echo "‚ö†Ô∏è  No changelog found: expected docs/README.md or docs/CHANGELOG.md in $version_dir"
                fi
              fi

              # Additional validation: Check if src contains Go files
              if [ -d "$version_dir/src" ] && [ -z "$(find "$version_dir/src" -name '*.go' 2>/dev/null)" ]; then
                echo "‚ö†Ô∏è  Warning: No Go files found in $version_dir/src"
              fi

              # Validate metadata.json structure (basic checks)
              if [ -f "$version_dir/metadata.json" ]; then
                # Check if it's valid JSON
                if ! jq empty "$version_dir/metadata.json" 2>/dev/null; then
                  echo "‚ùå Invalid JSON in metadata.json for $version_dir"
                  ((validation_errors++))
                else
                  # Check required metadata fields
                  required_metadata_fields=("name" "displayName" "provider" "categories" "description")
                  for field in "${required_metadata_fields[@]}"; do
                    if ! jq -e ".$field" "$version_dir/metadata.json" >/dev/null 2>&1; then
                      echo "‚ùå Missing required metadata field: $field in $version_dir/metadata.json"
                      ((validation_errors++))
                    fi
                  done
                fi
              fi

            done < <(find "$policy_dir" -mindepth 1 -maxdepth 1 -type d -print0)

          done < <(find policies -mindepth 1 -maxdepth 1 -type d -print0)

          if [ $validation_errors -gt 0 ]; then
            echo "‚ùå Validation failed with $validation_errors errors"
            exit 1
          fi

          echo "‚úÖ Structure validation passed"

      - name: Detect new policy versions in PR
        id: detect
        uses: ./.github/actions/detect-versions
        with:
          base-sha: ${{ github.event.pull_request.base.sha }}
          head-sha: ${{ github.event.pull_request.head.sha }}

      - name: Comment on PR with validation results
        if: always()
        run: |
          # Determine overall status
          if [ "${{ steps.validate.outcome }}" == "success" ]; then
            status="‚úÖ **Validation Passed**"
          else
            status="‚ùå **Validation Failed**"
          fi

          comment="## Policy Validation Results

$status

"

          # Add new versions section if any detected
          if [ -n "${{ steps.detect.outputs.new_versions }}" ]; then
            comment+="### New Policy Versions Detected:
"
            for version_path in ${{ steps.detect.outputs.new_versions }}; do
              policy=$(echo "$version_path" | cut -d'/' -f1)
              version=$(echo "$version_path" | cut -d'/' -f2)
              comment+=" - **$policy** $version
"
            done
            comment+="
These versions will be published in the next batch release."
          else
            comment+="### No New Policy Versions
This PR does not add new policy versions."
          fi

          # Add helpful information
          comment+="
### Policy Structure Requirements

#### Required Files:
- \`metadata.json\` - Policy metadata with name, displayName, provider, categories, description
- \`policy-definition.yaml\` - Policy definition with parameters schema and processing mode

#### Required Directories:
- \`src/\` - Go source code implementation
- \`docs/\` - Documentation (see below)

#### Documentation Structure (\`docs/\`):
- \`overview.md\` - Policy overview and description
- \`configuration.md\` - Configuration parameters and usage
- \`examples.md\` - Usage examples and code samples
- \`faq.md\` - Frequently asked questions (optional)
- \`README.md\` or \`CHANGELOG.md\` - Version changelog

#### Optional Directories:
- \`assets/\` - Icons, banners, and other media files

#### Metadata Requirements:
The \`metadata.json\` must contain:
- \`name\`, \`displayName\`, \`provider\`
- \`categories\` (array), \`description\`
- \`tags\` (optional), \`documentation\` mapping

### Next Steps
1. Fix any validation errors shown above
2. Ensure all required files and directories are present
3. Verify metadata.json contains all required fields
4. Ensure PR is reviewed and approved
5. Merge PR to main branch
6. Create GitHub release to trigger batch publishing"

          gh pr comment ${{ github.event.pull_request.number }} --body "$comment" || echo "Failed to post comment"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}